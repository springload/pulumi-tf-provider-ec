# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'GetECStackResult',
    'AwaitableGetECStackResult',
    'get_ec_stack',
]

@pulumi.output_type
class GetECStackResult:
    """
    A collection of values returned by getECStack.
    """
    def __init__(__self__, accessible=None, allowlisted=None, apms=None, elasticsearches=None, enterprise_searches=None, id=None, kibanas=None, lock=None, min_upgradable_from=None, region=None, upgradable_tos=None, version=None, version_regex=None):
        if accessible and not isinstance(accessible, bool):
            raise TypeError("Expected argument 'accessible' to be a bool")
        pulumi.set(__self__, "accessible", accessible)
        if allowlisted and not isinstance(allowlisted, bool):
            raise TypeError("Expected argument 'allowlisted' to be a bool")
        pulumi.set(__self__, "allowlisted", allowlisted)
        if apms and not isinstance(apms, list):
            raise TypeError("Expected argument 'apms' to be a list")
        pulumi.set(__self__, "apms", apms)
        if elasticsearches and not isinstance(elasticsearches, list):
            raise TypeError("Expected argument 'elasticsearches' to be a list")
        pulumi.set(__self__, "elasticsearches", elasticsearches)
        if enterprise_searches and not isinstance(enterprise_searches, list):
            raise TypeError("Expected argument 'enterprise_searches' to be a list")
        pulumi.set(__self__, "enterprise_searches", enterprise_searches)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if kibanas and not isinstance(kibanas, list):
            raise TypeError("Expected argument 'kibanas' to be a list")
        pulumi.set(__self__, "kibanas", kibanas)
        if lock and not isinstance(lock, bool):
            raise TypeError("Expected argument 'lock' to be a bool")
        pulumi.set(__self__, "lock", lock)
        if min_upgradable_from and not isinstance(min_upgradable_from, str):
            raise TypeError("Expected argument 'min_upgradable_from' to be a str")
        pulumi.set(__self__, "min_upgradable_from", min_upgradable_from)
        if region and not isinstance(region, str):
            raise TypeError("Expected argument 'region' to be a str")
        pulumi.set(__self__, "region", region)
        if upgradable_tos and not isinstance(upgradable_tos, list):
            raise TypeError("Expected argument 'upgradable_tos' to be a list")
        pulumi.set(__self__, "upgradable_tos", upgradable_tos)
        if version and not isinstance(version, str):
            raise TypeError("Expected argument 'version' to be a str")
        pulumi.set(__self__, "version", version)
        if version_regex and not isinstance(version_regex, str):
            raise TypeError("Expected argument 'version_regex' to be a str")
        pulumi.set(__self__, "version_regex", version_regex)

    @property
    @pulumi.getter
    def accessible(self) -> bool:
        return pulumi.get(self, "accessible")

    @property
    @pulumi.getter
    def allowlisted(self) -> bool:
        return pulumi.get(self, "allowlisted")

    @property
    @pulumi.getter
    def apms(self) -> Sequence['outputs.GetECStackApmResult']:
        return pulumi.get(self, "apms")

    @property
    @pulumi.getter
    def elasticsearches(self) -> Sequence['outputs.GetECStackElasticsearchResult']:
        return pulumi.get(self, "elasticsearches")

    @property
    @pulumi.getter(name="enterpriseSearches")
    def enterprise_searches(self) -> Sequence['outputs.GetECStackEnterpriseSearchResult']:
        return pulumi.get(self, "enterprise_searches")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The provider-assigned unique ID for this managed resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def kibanas(self) -> Sequence['outputs.GetECStackKibanaResult']:
        return pulumi.get(self, "kibanas")

    @property
    @pulumi.getter
    def lock(self) -> Optional[bool]:
        return pulumi.get(self, "lock")

    @property
    @pulumi.getter(name="minUpgradableFrom")
    def min_upgradable_from(self) -> str:
        return pulumi.get(self, "min_upgradable_from")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="upgradableTos")
    def upgradable_tos(self) -> Sequence[str]:
        return pulumi.get(self, "upgradable_tos")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="versionRegex")
    def version_regex(self) -> str:
        return pulumi.get(self, "version_regex")


class AwaitableGetECStackResult(GetECStackResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetECStackResult(
            accessible=self.accessible,
            allowlisted=self.allowlisted,
            apms=self.apms,
            elasticsearches=self.elasticsearches,
            enterprise_searches=self.enterprise_searches,
            id=self.id,
            kibanas=self.kibanas,
            lock=self.lock,
            min_upgradable_from=self.min_upgradable_from,
            region=self.region,
            upgradable_tos=self.upgradable_tos,
            version=self.version,
            version_regex=self.version_regex)


def get_ec_stack(lock: Optional[bool] = None,
                 region: Optional[str] = None,
                 version_regex: Optional[str] = None,
                 opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetECStackResult:
    """
    Use this data source to access information about an existing resource.
    """
    __args__ = dict()
    __args__['lock'] = lock
    __args__['region'] = region
    __args__['versionRegex'] = version_regex
    if opts is None:
        opts = pulumi.InvokeOptions()
    if opts.version is None:
        opts.version = _utilities.get_version()
    __ret__ = pulumi.runtime.invoke('ec:index/getECStack:getECStack', __args__, opts=opts, typ=GetECStackResult).value

    return AwaitableGetECStackResult(
        accessible=__ret__.accessible,
        allowlisted=__ret__.allowlisted,
        apms=__ret__.apms,
        elasticsearches=__ret__.elasticsearches,
        enterprise_searches=__ret__.enterprise_searches,
        id=__ret__.id,
        kibanas=__ret__.kibanas,
        lock=__ret__.lock,
        min_upgradable_from=__ret__.min_upgradable_from,
        region=__ret__.region,
        upgradable_tos=__ret__.upgradable_tos,
        version=__ret__.version,
        version_regex=__ret__.version_regex)
